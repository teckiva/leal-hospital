// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: patient_opd.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const createPatientOPD = `-- name: CreatePatientOPD :execresult
INSERT INTO patient_opd (
    patient_id, doctor_id, symptoms, prescription,
    medicines, future_suggestion, template_version
) VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreatePatientOPDParams struct {
	PatientID        int64           `json:"patient_id"`
	DoctorID         int64           `json:"doctor_id"`
	Symptoms         json.RawMessage `json:"symptoms"`
	Prescription     json.RawMessage `json:"prescription"`
	Medicines        json.RawMessage `json:"medicines"`
	FutureSuggestion json.RawMessage `json:"future_suggestion"`
	TemplateVersion  int32           `json:"template_version"`
}

func (q *Queries) CreatePatientOPD(ctx context.Context, arg CreatePatientOPDParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createPatientOPD,
		arg.PatientID,
		arg.DoctorID,
		arg.Symptoms,
		arg.Prescription,
		arg.Medicines,
		arg.FutureSuggestion,
		arg.TemplateVersion,
	)
}

const getLatestPatientOPD = `-- name: GetLatestPatientOPD :one
SELECT id, patient_id, doctor_id, symptoms, prescription, medicines, future_suggestion, template_version, created_on, updated_on FROM patient_opd
WHERE patient_id = ?
ORDER BY created_on DESC
LIMIT 1
`

func (q *Queries) GetLatestPatientOPD(ctx context.Context, patientID int64) (PatientOpd, error) {
	row := q.db.QueryRowContext(ctx, getLatestPatientOPD, patientID)
	var i PatientOpd
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.DoctorID,
		&i.Symptoms,
		&i.Prescription,
		&i.Medicines,
		&i.FutureSuggestion,
		&i.TemplateVersion,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const getPatientOPDByID = `-- name: GetPatientOPDByID :one
SELECT id, patient_id, doctor_id, symptoms, prescription, medicines, future_suggestion, template_version, created_on, updated_on FROM patient_opd WHERE id = ?
`

func (q *Queries) GetPatientOPDByID(ctx context.Context, id int64) (PatientOpd, error) {
	row := q.db.QueryRowContext(ctx, getPatientOPDByID, id)
	var i PatientOpd
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.DoctorID,
		&i.Symptoms,
		&i.Prescription,
		&i.Medicines,
		&i.FutureSuggestion,
		&i.TemplateVersion,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const getPatientOPDsByDoctor = `-- name: GetPatientOPDsByDoctor :many
SELECT po.id, po.patient_id, po.doctor_id, po.symptoms, po.prescription, po.medicines, po.future_suggestion, po.template_version, po.created_on, po.updated_on, lp.name as patient_name, lp.mobile as patient_mobile
FROM patient_opd po
JOIN lael_patients lp ON po.patient_id = lp.id
WHERE po.doctor_id = ?
ORDER BY po.created_on DESC
LIMIT ? OFFSET ?
`

type GetPatientOPDsByDoctorParams struct {
	DoctorID int64 `json:"doctor_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type GetPatientOPDsByDoctorRow struct {
	ID               int64           `json:"id"`
	PatientID        int64           `json:"patient_id"`
	DoctorID         int64           `json:"doctor_id"`
	Symptoms         json.RawMessage `json:"symptoms"`
	Prescription     json.RawMessage `json:"prescription"`
	Medicines        json.RawMessage `json:"medicines"`
	FutureSuggestion json.RawMessage `json:"future_suggestion"`
	TemplateVersion  int32           `json:"template_version"`
	CreatedOn        time.Time       `json:"created_on"`
	UpdatedOn        time.Time       `json:"updated_on"`
	PatientName      string          `json:"patient_name"`
	PatientMobile    string          `json:"patient_mobile"`
}

func (q *Queries) GetPatientOPDsByDoctor(ctx context.Context, arg GetPatientOPDsByDoctorParams) ([]GetPatientOPDsByDoctorRow, error) {
	rows, err := q.db.QueryContext(ctx, getPatientOPDsByDoctor, arg.DoctorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPatientOPDsByDoctorRow{}
	for rows.Next() {
		var i GetPatientOPDsByDoctorRow
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.DoctorID,
			&i.Symptoms,
			&i.Prescription,
			&i.Medicines,
			&i.FutureSuggestion,
			&i.TemplateVersion,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.PatientName,
			&i.PatientMobile,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPatientOPDsByPatientID = `-- name: GetPatientOPDsByPatientID :many
SELECT id, patient_id, doctor_id, symptoms, prescription, medicines, future_suggestion, template_version, created_on, updated_on FROM patient_opd
WHERE patient_id = ?
ORDER BY created_on DESC
`

func (q *Queries) GetPatientOPDsByPatientID(ctx context.Context, patientID int64) ([]PatientOpd, error) {
	rows, err := q.db.QueryContext(ctx, getPatientOPDsByPatientID, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PatientOpd{}
	for rows.Next() {
		var i PatientOpd
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.DoctorID,
			&i.Symptoms,
			&i.Prescription,
			&i.Medicines,
			&i.FutureSuggestion,
			&i.TemplateVersion,
			&i.CreatedOn,
			&i.UpdatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
