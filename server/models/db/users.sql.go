// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package db

import (
	"context"
	"database/sql"
)

const approveStaff = `-- name: ApproveStaff :exec
UPDATE lael_users
SET is_approved = TRUE, approved_by = ?, updated_on = NOW()
WHERE id = ?
`

type ApproveStaffParams struct {
	ApprovedBy sql.NullInt64 `json:"approved_by"`
	ID         int64         `json:"id"`
}

func (q *Queries) ApproveStaff(ctx context.Context, arg ApproveStaffParams) error {
	_, err := q.db.ExecContext(ctx, approveStaff, arg.ApprovedBy, arg.ID)
	return err
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO lael_users (
    name, mobile, email, designation, is_admin, is_approved, password_hash
) VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateUserParams struct {
	Name         string               `json:"name"`
	Mobile       string               `json:"mobile"`
	Email        string               `json:"email"`
	Designation  LaelUsersDesignation `json:"designation"`
	IsAdmin      bool                 `json:"is_admin"`
	IsApproved   bool                 `json:"is_approved"`
	PasswordHash sql.NullString       `json:"password_hash"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUser,
		arg.Name,
		arg.Mobile,
		arg.Email,
		arg.Designation,
		arg.IsAdmin,
		arg.IsApproved,
		arg.PasswordHash,
	)
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, mobile, email, designation, status, is_admin, is_approved, approved_by, password_hash, created_on, updated_on, last_login_at FROM lael_users WHERE email = ?
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (LaelUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i LaelUser
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Mobile,
		&i.Email,
		&i.Designation,
		&i.Status,
		&i.IsAdmin,
		&i.IsApproved,
		&i.ApprovedBy,
		&i.PasswordHash,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.LastLoginAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, mobile, email, designation, status, is_admin, is_approved, approved_by, password_hash, created_on, updated_on, last_login_at FROM lael_users WHERE id = ?
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (LaelUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i LaelUser
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Mobile,
		&i.Email,
		&i.Designation,
		&i.Status,
		&i.IsAdmin,
		&i.IsApproved,
		&i.ApprovedBy,
		&i.PasswordHash,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.LastLoginAt,
	)
	return i, err
}

const getUserByMobile = `-- name: GetUserByMobile :one
SELECT id, name, mobile, email, designation, status, is_admin, is_approved, approved_by, password_hash, created_on, updated_on, last_login_at FROM lael_users WHERE mobile = ?
`

func (q *Queries) GetUserByMobile(ctx context.Context, mobile string) (LaelUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByMobile, mobile)
	var i LaelUser
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Mobile,
		&i.Email,
		&i.Designation,
		&i.Status,
		&i.IsAdmin,
		&i.IsApproved,
		&i.ApprovedBy,
		&i.PasswordHash,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.LastLoginAt,
	)
	return i, err
}

const listPendingStaffApprovals = `-- name: ListPendingStaffApprovals :many
SELECT id, name, mobile, email, designation, status, is_admin, is_approved, approved_by, password_hash, created_on, updated_on, last_login_at FROM lael_users
WHERE is_admin = FALSE AND is_approved = FALSE
ORDER BY created_on DESC
`

func (q *Queries) ListPendingStaffApprovals(ctx context.Context) ([]LaelUser, error) {
	rows, err := q.db.QueryContext(ctx, listPendingStaffApprovals)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LaelUser{}
	for rows.Next() {
		var i LaelUser
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Mobile,
			&i.Email,
			&i.Designation,
			&i.Status,
			&i.IsAdmin,
			&i.IsApproved,
			&i.ApprovedBy,
			&i.PasswordHash,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.LastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaffByStatus = `-- name: ListStaffByStatus :many
SELECT id, name, mobile, email, designation, status, is_admin, is_approved, approved_by, password_hash, created_on, updated_on, last_login_at FROM lael_users
WHERE is_admin = FALSE AND status = ?
ORDER BY name ASC
LIMIT ? OFFSET ?
`

type ListStaffByStatusParams struct {
	Status LaelUsersStatus `json:"status"`
	Limit  int32           `json:"limit"`
	Offset int32           `json:"offset"`
}

func (q *Queries) ListStaffByStatus(ctx context.Context, arg ListStaffByStatusParams) ([]LaelUser, error) {
	rows, err := q.db.QueryContext(ctx, listStaffByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LaelUser{}
	for rows.Next() {
		var i LaelUser
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Mobile,
			&i.Email,
			&i.Designation,
			&i.Status,
			&i.IsAdmin,
			&i.IsApproved,
			&i.ApprovedBy,
			&i.PasswordHash,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.LastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLastLogin = `-- name: UpdateLastLogin :exec
UPDATE lael_users
SET last_login_at = NOW(), updated_on = NOW()
WHERE id = ?
`

func (q *Queries) UpdateLastLogin(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateLastLogin, id)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE lael_users
SET password_hash = ?, updated_on = NOW()
WHERE id = ?
`

type UpdateUserPasswordParams struct {
	PasswordHash sql.NullString `json:"password_hash"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.PasswordHash, arg.ID)
	return err
}

const updateUserStatus = `-- name: UpdateUserStatus :exec
UPDATE lael_users
SET status = ?, updated_on = NOW()
WHERE id = ?
`

type UpdateUserStatusParams struct {
	Status LaelUsersStatus `json:"status"`
	ID     int64           `json:"id"`
}

func (q *Queries) UpdateUserStatus(ctx context.Context, arg UpdateUserStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateUserStatus, arg.Status, arg.ID)
	return err
}
